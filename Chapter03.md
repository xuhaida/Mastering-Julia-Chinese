本章和下一章里，我们会讨论一些特性，使得Julia吸引数据科学家和科学程序员。

Julia脱胎于为了为满足不满于现有程序语言的主要的程序员，被良好设计，并且优美。而且，大部分代码用Julia书写，因此便于审查和修改。尽管我们不提倡对现有的代码进行修改（也被成为标准库），还是值得看看和学习的。

**函数**

我们在前面的章节里遇到过函数，，并且知道function() ... end语句段落的工作方式，但是一些例子中有一个单行的语法。

即，sq(x)=x*x就相当于下面的代码：

        function sq(x)
          y=x*x
          returen y
        end

变量y不是必须的。它是函数sq()的局部变量，在函数调用以外并不存在。因此，最后的语句中可以改写成return x*x,甚至x*x，因为Julia会返回最后的变量。

**第一等公民对象**

函数是

**Julia类型系统**

Julia并非面向对象语言，因此，当我们谈及对象，它们是与传统的OO语言不同的数据结构。

Julia不允许类型拥有方法，因此就不能够通过子类型来继承方法。尽管有些受限制，但是他允许方法多分发来调用结构，而不是面向对象语言中的单分发。

配合于Julia的类型系统，多分发非常强大。而且，对于科学工作者和科学程序员来说，更加符合其逻辑方法。如果这不是你的理由，至少对于分析师和程序员来书，确是其使用Julia的理由。实际上，我们后面会看到，还有其他理由。

**有理数类型**

有理数类型在前面的章节中已经有所介绍。像Julia大部分代码一样，该类型是用Julia实现，源码位于base/rational.jl，以供审查。因为Rational为基础类型，不需要显式载入，我们可以直接加以应用。

        julia> names(Rational)

names()函数会列出面向对象中所谓的性质，但是Julia会列出一个符号数组。Julia用：号来作为前缀来表示字符，当我们涉及宏时会有更多内容关于字符。

:num表示有理数的分子，而:den表示分母。

来看一下我们是如何构建Rational类型的，我们使用methods()函数：

        julia> methods(Rational)

很明显，我们希望使用整数而不是浮点数来构建有理数，但是，Julia语言中的整型，因为大小不同，范围从int8至int32,我们还会用到符号和无符号型。

与其提供方法来生成任何组合的有理数，Julia提供了3中泛型方式，methods()函数有助于它们的源代码:

- Rational(n:Integer):
- Rational(n:Integer,d::Integer):
- Rational{T<:Integer}(n::T,d::T):

参数定义是非常有用，会建立起类型曹祖的规则，正如我们后面会看到的。

整个代码非常长，但是前面的代码非常富含信息，摘录如下：

有理数类型用immutable语句定义，而不是type。这种做法并不意味着有理数定义完后，不能改变，只是让改变变得困难 。

尽管我们说过类型定义中不包含方法，但是与类型同名的函数是例外，被称为内部构造函数。

有一个方法可以用来构建数据类型。有理数类型中。就有理数类型而言，构造函数检查分母是否为0，注意，在错误语句中使用了短路求值。

其他，构造函数找到分子和分母的最大公约数（GCD），来将2个数还原至最简形式。特别函数new()来返回一个值或者类型。

对于不同类型，可以有不同的外部构造函数来构建不同类型的有理数。

另外一件事，是有理数也可以用复数来定义，只有复数的实数和虚数部分都为整数。实际上，这很容易做到，通过将有理数用共轭复数进行相乘。注意，Real的使用非虚函数而不是浮点数。整数位Real类型的一种。

Rational.jl的其他代码处理了数学运算。我们在讨论参数类型和多分派时会看到如何做到。

**汽车类型**

让我们从头构建数据类型，作为例子，让我们看一下数据结构描述了汽车和他们的所有者，这些会出现在vehicles.jl中，可以在Julia环境中使用include()语句进行加载或者被打包。

          type Contact
            name::String
            email::String
            phone::String
          end

所有的汽车会有一个人士(或者公司)负责，这会提供最少的信息，包括名字，电话号码。所有都可以是字符串或者是空字符。

定义中创见了默认的构造函数，只是定义了一个新的联系方式通过提供参数。为了给成员或者加入其他的限制条件，我们需要提供一个内部构造函数。

        function Contact(name::String,email::String,phone::String)

          length(name)==0 && error("Need to provide a      contact name")
          length(email)==0 && length(phone) ==0 &&
          error("Need to provide either an email or a phone number")
          new(name,email,phone)
        end

现在，我们只是拥有一个构造函数和一个组合规则，email和电话号码必有其一，正如没有用的联系方式，我们根本不可能联系上。这里，我们可以加入最大字符串长度，队友数据结构最终是需要的，被加入至数据库中。

        abstract Vechile
        abstract Car <: Vehicle
        abstract Bike <: vehicle
        abstract Boat <: vehicle
        abstract Powerboat <: Boat

该组语句中，
      　
